;;;;; egison3

;;; Type system

;; Type Examples
Something BuidinBool BuidinChar BuidinString BuidinInteger BuidinFloat
(Type : Type)
([Integer Integer] : Integer)
([($a : $b) {a}] : {b})
(Show $a) |- ({a} : String)

(define $map :: ([($a : $b) {a}] : {b})
  (lambda ...))

(define $List :: (Type : Type)
  (lambda [$a]
    (type {a}
      {...})))
    
(define $BTree :: (Type : Type)
  (lambda [$a]
    (algebraic-data-type (BTree a)
      (|| <leaf a>
          <node (BTree a) (NTree a)>))))

(define $Integer :: Type
  (type Integer
    {[,$n []
      {[$tgt (if (eq-integer? tgt n)
                 {[]}
                 {})]}]}))

(define $Mod :: (Type : Type)
  (lambda [$m]
    (type Integer
      {[,$n []
        {[$tgt (if (eq? (mod tgt m) (mod n m))
                   {[]}
                   {})]}]
       [_ [Integer]
	    {[$tgt {(mod tgt m)}]}]
       })))

;; Class Example
(define $Show :: (Type : Class)
  (lambda [$a]
    (class
      {$show :: (a : String)
       })))

(instance (Show Integer) {[$show show_integer]})

;;; Module system

(module $json)

(export {encode decode})

(import json)

;;; first class patterns

Only varialbes in value patterns should be able to refer to the result of the processing of the pattern matching.

(define $shuntsu :: ([Variable Pattern] : Pattern)
  (lambda [$s $pat]
    <cons $`s <cons ,(+ `s 1) <cons ,(+ `s 2) pat>>>))

(define $test-pat :: ([Variable Integer] : Pattern)
  (lambda [$s $n]
    <cons $`s <cons ,(+ `s (+ 1 n)) _>>))

Two kinds of eval
- Eval to a pattern ('`' in the value patterns also should be removed)
- Eval for patterns

(test-pat %x 10)
'Eval to a pattern' process -> <cons $x <cons ,(+ x (+ 1 10)) _>>

Variables in a value pattern should be evaluated in 'Eval to a pattern' process.
But, expressions in a value pattern should not be evaluated in 'Eval to a pattern' process.
*** '(+ 1 10)' won't evaluated in 'Eval to a pattern' process.
