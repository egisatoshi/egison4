;;;;;
;;;;; Design of Egison3
;;;;;

;;;
;;; Type system
;;;

;;
;; Type Examples
;;

;
; Types are declared with ':' infix operator.
;    
(define $add : ([Integer Integer] -> Intger)
  (lambda [$x $y] (+ x y)))

;
; Data which defines how to pattern-match is called `matcher'.
; A mather is defined with a matcher expression.
; A mather expression takes primitive-match-clauses as a type expression of Egison2.
; The type of matcher is "(Matcher <target-type>)".
; "Matcher" is primitive-pattern-constructor as '->'.
;
(define $integer : (Matcher Integer)
  (matcher
    {[,$n []
      {[$tgt (if (= tgt n)
                 {[]}
                 {})]}]
     [_ [something]
      {[$tgt {tgt}]}]}))

;
; Types and mathers have one-to-many relationships.
; e.g.
; Integer -> integer
;         -> (mod 10)
;         -> (mod 100)
;
(define $mod : (Integer -> (Matcher Integer))
  (lambda [$m]
    (matcher Integer
      {[,$n []
        {[$tgt (if (= (mod tgt m) (mod n m))
                   {[]}
                   {})]}]
       [_ [integer]
	    {[$tgt {(mod tgt m)}]}]
       })))

(define $list : ((Matcher $a) -> (Matcher (Collection ,a)))
  (lambda [$a]
    (matcher
      {[,$val []
        {[$tgt (match [val tgt] [(list a) (list a)]
                 {[[<nil> <nil>] {[]}]
                  [[<cons $x $xs> <cons ,x ,xs>] {[]}]
                  [[_ _] {}]})]}]
       [<nil> []
        {[{} {[]}]
         [_ {}]}]
       [<cons _ _> [a (list a)]
        {[{$x .$xs} {[x xs]}]
         [_ {}]}]
       [<snoc _ _> [a (list a)]
        {[{.$xs $x} {[x xs]}]
         [_ {}]}]
       [<join ,$pxs _> [(list a)]
        {[$tgt (letrec {[$helper (lambda [$pxs $tgt]
                                   (match [pxs tgt] [(list a) (list a)]
                                     {[[<nil> _] {tgt}]
                                      [[<cons $x $xs> <cons ,x $ys>] (helper xs ys)]
                                      [[_ _] {}]}))]}
                 (helper pxs tgt))]}]
       [<join _ _> [(list a) (list a)]
	    {[$tgt (letrec {[$helper (lambda [$xs $ys]
				                   (match ys (list a)
				                     {[<nil> {[xs {}]}]
				                      [<cons $z $zs> {[xs ys] @(helper {@xs z} zs)}]}))]}
		         (helper {} tgt))]}]
       [<nioj ,$pxs _> [(list a)]
        {[$tgt (match-all tgt (list a) [<join $ys ,pxs> ys])]}]
       [<nioj _ _> [(list a) (list a)]
	    {[$tgt (letrec {[$helper (lambda [$xs $ys]
				                   (match ys (list a)
				                     {[<nil> {[{} xs]}]
				                      [<cons $z $zs> {[ys xs] @(helper {@xs z} zs)}]}))]}
		         (helper {} tgt))]}]
       [_ [something]
        {[$tgt {tgt}]}]
       )))

;
; Types of types are declared with '::' infix operator.
; A matcher "tree" is auot-generated by the definition of "Tree" algebraic-data-type.
;
(define-type $Tree :: SomeType -> SomeType
  (type-lambda [$a]
    (algebraic-data-type
      {<leaf a>
       <node (Tree a) (Tree a)>
       })))

(define $map : ([($a -> $b) (Collection ,a)] -> (Collection ,b))
  (lambda [$fn $ls]
    (match ls (list something)
      {[<nil> {}]
       [<cons $x $xs> {(fn x) @(map fn xs)}]})))

(define $remove : ([(Matcher $a) (Collection ,a) ,a] -> (Collection ,a))
  (lambda [$typ $xs $x]
    (match xs (list typ)
      {[<nil> {}]
       [<cons ,x $rs> rs]
       [<cons $y $rs> {y @(remove a rs x)}]})))

(test (remove (mod 13) {10 2 14} 1))

;;
;; Class Example
;;

(define-class $Show $a
  {$show : (,a -> String)})

(define-class $Eq $a
  {$= : ([,a ,a] -> Bool)})

(define-class $Ord [$a $b]
  {$lt : ([,a ,b] -> String)
   $gt : ([,a ,b] -> String)
   $le : ([,a ,b] -> String)
   $ge : ([,a ,b] -> String)})

(class-instance Show Char {[$show show-char]})
(class-instance Show Integer {[$show show-integer]})
(class-instance Show String {[$show id]})

(class-instance Ord [Integer Integer]
  {[lt lt-i]
   [gt gt-i]
   [le lt-i]
   [ge gt-i]})

(define $print : ($a :: Show -> String))
  (lambda [x] (++ (show x) "\n")))

;;;
;;; Module system
;;;

;;
;; Very simple module system, for now.
;;

(module $json)

(export {encode decode})

(import json)

;;;
;;; Evaluation of patterns -- First class patterns
;;;

;;
;; Egison3 does not have macro as Egison2.
;;

;
; Only varialbes in value patterns should be able to refer to the result of the processing of the pattern matching.
; "Pattern" is a primitive-pattern-constructor introdueced with Egison3 as "Matcher".
;
(define $shuntsu : ([VarName (Pattern (Collection Integer))] -> (Pattern (Collection Integer)))
  (lambda [$s $pat]
    <cons $`s <cons ,(+ `s 1) <cons ,(+ `s 2) pat>>>))

(define $test-pat : ([VarName Integer] -> (Pattern (Collection Integer)))
  (lambda [$s $n]
    ,(+ `s (+ 1 n))))

; Evaluation for patterns has three phase.
; (test-pat %x 10)
; 1. Create a value-pattern-closure.
;    -> (ValuePatternClosure env (+ `%x (+ 1 n)))
; 2. Expand `%var with the result in the middle of pattern matching
;    -> (ValuePatternClosure env (+ 3 (+ 1 n)))
; 3. Evaluate value-pattern-closure
;    -> 14

;;;
;;; Buildins
;;;

;;
;; Buildin Types
;;

Nothing
Bool
Integer
Float
Double
Char
String

VarName

IO

;;
;; Buildin Class
;;

Show
Eq
Ord
