;;;;;
;;;;; Design of Egison3
;;;;;

;;;
;;; Type system
;;;

;;
;; Type Examples
;;

;
; Types are declared with ':' infix operator.
; ':' operator is left-associative.
;    
(define $add : ([Integer Integer] -> Intger)
  (lambda [$x $y] (+ x y)))

;
; Data which defines how to pattern-match is called `matcher'.
; A mather is defined with a matcher expression.
; A mather expression takes primitive-match-clauses as a type expression of Egison2.
; The type of matcher is "(Matcher <target-type>)".
; "Matcher" is primitive-pattern-constructor as '->'.
;
(define $integer : (Matcher Integer)
  (matcher
    {[,$val []
      {[$tgt (if (eq? val tgt)
                 {[]}
                 {})]}]
     [$ [something]
      {[$tgt {tgt}]}]}))

;
; Types and mathers have one-to-many relationships.
; e.g.
; Integer -> integer
;         -> (mod 10)
;         -> (mod 100)
;
(define $mod : (Integer -> (Matcher Integer))
  (lambda [$m]
    (matcher
      {[,$val []
	    {[$tgt (if (eq? (mod val m) (mod tgt m))
                   {[]}
                   {})]}]
       [$ [integer]
	    {[$tgt {(mod tgt m)}]}]
       })))

(define $equal?
  (lambda [$matcher]
    (function [matcher matcher]
      {[[$zs ,zs] #t]
       [_ #f]})))

(define $list : ((Matcher $a) -> (Matcher (Collection ,a)))
  (lambda [$a]
    (matcher
      {[,$val []
        {[$tgt (if ((equal-list? a) val tgt)
                   {[]}
                   {})]}]
       [<nil> []
        {[{} {[]}]
         [_ {}]}]
       [<cons $ $> [a (list a)]
        {[{$x .$xs} {[x xs]}]
         [_ {}]}]
       [<snoc $ $> [a (list a)]
        {[{.$xs $x} {[x xs]}]
         [_ {}]}]
       [<join ,$hs $> [(list a)]
        {[$tgt (letrec {[$looper (function [(list a) (list a)]
                                   {[[<nil> $ys] {ys}]
                                    [[<cons $x $xs2> <cons ,x $ys2>] (looper xs2 ys2)]
                                    [[_ _] {}]})]}
                 (looper hs tgt))]}]
       [<join $ $> [(list a) (list a)]
        {[$tgt (letrec {[$looper (lambda [$ret $xs $ys]
                                   (match ys (list a)
                                     {[<nil> {@ret [xs {}]}]
                                      [<cons $y $ys2> (looper {@ret [xs ys]} {@xs y} ys2)]}))]}
                 (looper {} {} tgt))]}]
       [<nioj ,$ts $> [(list a)]
        {[$tgt (letrec {[$looper (function [(list a) (list a)]
                                   {[[<nil> $ys] {ys}]
                                    [[<snoc $x $xs2> <snoc ,x $ys2>] (looper xs2 ys2)]
                                    [[_ _] {}]})]}
                 (looper ts tgt))]}]
       [<nioj $ $> [(list a) (list a)]
        {[$tgt (letrec {[$looper (lambda [$ret $xs $ys]
                                   (match ys (list a)
                                     {[<nil> {@ret [xs {}]}]
                                      [<snoc $y $ys2> (looper {[xs ys] @ret} {@xs y} ys2)]}))]}
                 (looper {} {} tgt))]}]
       [$ [something]
        {[$tgt {tgt}]}]
       ))))

(define $multiset : ((Matcher $a) -> (Matcher (Collection ,a)))
  (lambda [$a]
    (matcher
      {[,$val []
        {[$tgt (if ((equal-multiset? a) val tgt)
                   {[]}
                   {})]}]
       [<nil> []
        {[{} {[]}]
         [_ {}]}]
       [<cons $ $> [a (multiset a)]
        [$tgt (match-all tgt (list a)
                [<join $hs <cons $x $ts>> [x {@hs @ts}]])]]
       [<join ,$xs $> [(multiset a)]
        [$tgt (if ((include? (multiset a)) tgt xs)
                  {((remove-collection a) tgt xs)}
                  {})]]
       [$ [something]
        {[$tgt {tgt}]}]
       })))

(define $set : ((Matcher $a) -> (Matcher (Collection ,a)))
  (lambda [$a]
    (matcher
      {[<nil> []
        {[{} {[]}]
         [_ {}]}]
       [<cons $ $> [a (set a)]
        [$tgt (match-all tgt (list a)
                [<join _ <cons $x _>> [x tgt]])]]
       [$ [something]
        {[$tgt {tgt}]}]
       })))

;
; Types of types are declared with '::' infix operator.
; '::' operator is left-associative as ':'.
; A matcher "tree" is auot-generated by the definition of "Tree" algebraic-data-type.
;
(define-type $Tree :: Type -> Type
  (type-lambda [$a]
    (algebraic-data-type
      {<leaf a>
       <node (Tree a) (Tree a)>
       })))

(define-type $Ordering :: Type
  (algebraic-data-type
    {<less>
     <equal>
     <greater>
     }))

(define $map : ([($a -> $b) (Collection ,a)] -> (Collection ,b))
  (lambda [$fn $ls]
    (match ls (list something)
      {[<nil> {}]
       [<cons $x $xs> {(fn x) @(map fn xs)}]})))

(define $remove : ([(Matcher $a) (Collection ,a) ,a] -> (Collection ,a))
  (lambda [$matcher]
    (lambda [$xs $x]
      (match xs (list typ)
        {[<nil> {}]
         [<cons ,x $rs> rs]
         [<cons $y $rs> {y @(remove a rs x)}]}))))

(test (remove (mod 13) {10 2 14} 1))

;;
;; Class Example
;;

(define-class $Show [$a]
  {$show : (,a -> String)})

(define-class $Eq [$a]
  {$eq? : ([,a ,a] -> Bool)})

(define-class $Ord [$a $b]
  {$compare : ([,a ,b] -> Ordering)
   $lt? : ([,a ,b] -> Bool)
   $gt? : ([,a ,b] -> Bool)
   $le? : ([,a ,b] -> Bool)
   $ge? : ([,a ,b] -> Bool)})

(instance Show Char {[$show show-char]})
(instance Show Integer {[$show show-integer]})
(instance Show String {[$show id]})

(instance Ord [Integer Integer]
  {[$compare compare-integer]
   [$lt? lt-i]
   [$gt? gt-i]
   [$le? lt-i]
   [$ge? gt-i]})

;
; ':' and '::' operator are left-associative.
; i.e. ($a :: Show -> String) is same with (($a :: Show) -> String).
;
(define $print : ($a :: Show -> String)
  (lambda [x] (++ (show x) "\n")))

;;;
;;; Partial evaluation
;;;

;
; 
; e.g. (+ $ 10) => (lambda [$x] (+ x 10))
;
((+ $ 10) 5)

((map $ id) {1 2 3})

;;
;; predicate pattern
;;

<cons ?(lambda [$x] (lt? x 10)) _>

<cons ?(lt? $ 10) _>

;;;
;;; Module system
;;;

;;
;; Very simple module system, for now.
;;

(module $json)

(export {encode decode})

(import json)

;;;
;;; Buildins
;;;

;;
;; Buildin Types
;;

Nothing
Bool
Integer
Float
Double
Char
String

VarName

IO

;;
;; Buildin Class
;;

Show
Eq
Ord
