;;;;; egison3

;;; Type system

;; Type Examples
    
(define $add : ([Integer Integer] -> Intger)
  (lambda [$x $y] (+ x y)))

(define $list : (Type -> Type)
  (lambda [$a]
    (type (Collection a)
       ...
       )))

(define $integer : Type
  (type Integer
    {[,$n []
      {[$tgt (if (= tgt n)
                 {[]}
                 {})]}]
     [_ [something]
      {[$tgt {tgt}]}]}))

(define $mod : (Integer -> Type)
  (lambda [$m]
    (type Integer
      {[,$n []
        {[$tgt (if (= (mod tgt m) (mod n m))
                   {[]}
                   {})]}]
       [_ [integer]
	    {[$tgt {(mod tgt m)}]}]
       })))

(define $map : (lambda [$a $b] ([(a -> b) {a}] -> {b})) :: ([SomeType SomeType] -> SomeType)
  (lambda [$fn $ls]
    (match ls (list something)
      {[<nil> {}]
       [<cons $x $xs> {(fn x) @(map fn xs)}]})))

(define $remove : (lambda [$a] ([Type {a} a] -> {a})) :: (Match -> SomeType)
  (lambda [$typ $xs $x]
    (match xs (list typ)
      {[<nil> {}]
       [<cons ,x $rs> rs]
       [<cons $y $rs> {y @(remove a rs x)}]})))

(test (remove (mod 13) {10 2 14} 1))

(define-type $Tree
  (lambda [$a] ;; ???
    (|| <leaf a>
        <node (tree a) (tree a)>)))

(define $tree : (Type -> Type)
  (lambda [$a]
    (algebraic-data-type (Tree a)
      (|| <leaf a>
          <node (tree a) (tree a)>))))


;; Class Example

(define-class $Show
  {[Integer {[$show show-integer]}]
   [String {[$show id]}]
   ...}))

(extend-class Show [Char {[$show show-char]}])  

(define $print : (lambda [$a] (a -> String)) :: (Show -> SomeType)
  (lambda [x] (++ (show x) "\n")))


;;; Module system

(module $json)

(export {encode decode})

(import json)

;;; first class patterns

Only varialbes in value patterns should be able to refer to the result of the processing of the pattern matching.

(define $shuntsu : ([Variable (Pattern {Integer})] -> (Pattern {Integer}))
  (lambda [$s $pat]
    <cons $`s <cons ,(+ `s 1) <cons ,(+ `s 2) pat>>>))

(define $test-pat : ([Variable Integer] -> (Pattern {Integer}))
  (lambda [$s $n]
    <cons $`s <cons ,(+ `s (+ 1 n)) _>>))

Two kinds of eval
- Eval to a pattern ('`' in the value patterns also should be removed)
- Eval for patterns

(test-pat %x 10)
'Eval to a pattern' process -> <cons $x <cons ,(+ x (+ 1 10)) _>>

Variables in a value pattern should be evaluated in 'Eval to a pattern' process.
But, expressions in a value pattern should not be evaluated in 'Eval to a pattern' process.
*** '(+ 1 10)' won't evaluated in 'Eval to a pattern' process.
