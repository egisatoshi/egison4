;;;;;
;;;;; Pattern Matching
;;;;;


;;;
;;; Pattern matching mechanism
;;; -- First class patterns
;;;

;;
;; Egison3 does not have macro as Egison2.
;;

;
; Only varialbes in value patterns and predicate patterns should be able to refer to the result of the processing of the pattern matching.
; (I don't think patterns like `<cons $fn (fn 10)>' is useful)
;
; "Pattern" is a primitive-pattern-constructor introdueced with Egison4 as "Matcher".
;

(define $test-pat : (\ [(PatVar Integer) Integer] (Pattern Integer))
  (lambda [$pvar $n]
    ,(+ `pvar (+ 1 n))))

;
; ``' omit `$' of the following pattern variable.
; `pvar' could be also writtern as `$`pvar'.
;

(define $test-pat2 : (\ [(PatVar Integer) Integer] (Pattern (Collection Integer)))
  (lambda [$pvar]
    <cons pvar <cons ?(dividable $ `pvar) _>>

; Evaluation for patterns has three phases.
; (test-pat $x 10)
; 1. Create a value-pattern-closure or predicate pattern.
;    -> (ValuePatternClosure env (+ `$x (+ 1 n)))
; 2. Expand and evaluate `%var ahead with the result in the middle of pattern matching on the environment of pattern matching expression
;    -> (ValuePatternClosure env (+ 3 (+ 1 n)))
; 3. Evaluate value-pattern-closure or predicate closure.
;    -> 14

patternMatch :: Environment -> [MatchState] -> IOThrowsError [MatchResult]
patternMatch _ _ [] = return []
patternMatch MatchOne env ((frame, []):_) = do
  return [frame]
patternMatch MatchAll env ((frame, []):mStates) = do
  ret <- patternMatch env mAtoms
  return (frame:ret)
patternMatch mFlag env ((frame, ((matcher,pattern,target):mAtoms)):mStates) = do
  rets <- patternMatchCore MatchAll env (frame, (matcher, pattern, target))
  patternMatch mFlag env ((map (\ret -> (ret, mAtoms)) rets) ++ mStates)

patternMatchCore :: Environment -> MatchResult -> EgisonObject -> EgisonObject -> EgisonObject -> IOThrowsError [MatchResult]
patternMatchCore env frame matcher pattern target =
  patternVal <- eval1 pattern
  case patternVal of
    (ValuePattern env expr) ->
       
evalValuePat env expr frame =
evalValuePat env (OmitExpr var nums) frame =
  case getValue env (var, nums) of
    (VarName var nums) -> cEval (getValueFromFrame frame (var, nums))
    _ -> throwError "..."
evalValuePat env expr frame = do
  val <- eval1 env expr
  evalValuePatRecursively env val frame
  

MatchFlag = MatchAll |  MatchOne

MatchState = [(MatchResult, [MatchAtom])]

MatchAtom = (Matcher, Pattern, Target)
