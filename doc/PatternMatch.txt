;;;;;
;;;;; Pattern Matching
;;;;;


;;;
;;; Pattern matching mechanism
;;; -- First class patterns
;;;

;;
;; Egison3 does not have macro as Egison2.
;;

;
; Only varialbes in value patterns and predicate patterns should be able to refer to the result of the processing of the pattern matching.
; (I don't think patterns like `<cons $fn (fn 10)>' is useful)
;
; "Pattern" is a primitive-pattern-constructor introdueced with Egison3 as "Matcher".
;
(define $shuntsu : (\ [(VarName Integer) (Pattern (Collection Integer))] (Pattern (Collection Integer)))
  (lambda [$s $pat]
    <cons $`s <cons ,(+ `s 1) <cons ,(+ `s 2) pat>>>))


; (shuntsu %n _)
; => <cons $n <cons ,(+ n 1) <cons ,(+ n 2) _>>>
; {1 2 3 3 4 5 2 3 4}

(define $test-pat : (\ [(VarName Integer) Integer] (Pattern Integer))
  (lambda [$s $n]
    ,(+ `s (+ 1 n))))

<cons $m <cons ?(dividable $ m) _>>

(define $test-pat2 : (\ [(VarName Integer) Integer] (Pattern (Collection Integer)))
  (lambda [$var]
    <cons $`var <cons ?(dividable $ `var) _>>

; Evaluation for patterns has three phases.
; (test-pat %x 10)
; 1. Create a value-pattern-closure or predicate pattern.
;    -> (ValuePatternClosure env (+ `%x (+ 1 n)))
; 2. Expand and evaluate `%var ahead with the result in the middle of pattern matching on the environment of pattern matching expression
;    -> (ValuePatternClosure env (+ 3 (+ 1 n)))
; 3. Evaluate value-pattern-closure or predicate closure.
;    -> 14

patternMatch :: Environment -> [MatchState] -> IOThrowsError [MatchResult]
patternMatch _ _ [] = return []
patternMatch MatchOne env ((frame, []):_) = do
  return [frame]
patternMatch MatchAll env ((frame, []):mStates) = do
  ret <- patternMatch env mAtoms
  return (frame:ret)
patternMatch mFlag env ((frame, ((matcher,pattern,target):mAtoms)):mStates) = do
  rets <- patternMatchCore MatchAll env (frame, (matcher, pattern, target))
  patternMatch mFlag env ((map (\ret -> (ret, mAtoms)) rets) ++ mStates)

patternMatchCore :: Environment -> MatchResult -> EgisonObject -> EgisonObject -> EgisonObject -> IOThrowsError [MatchResult]
patternMatchCore env frame matcher pattern target =
  patternVal <- eval1 pattern
  case patternVal of
    (ValuePattern env expr) ->
       
evalValuePat env expr frame =
evalValuePat env (OmitExpr var nums) frame =
  case getValue env (var, nums) of
    (VarName var nums) -> cEval (getValueFromFrame frame (var, nums))
    _ -> throwError "..."
evalValuePat env expr frame = do
  val <- eval1 env expr
  evalValuePatRecursively env val frame
  

MatchFlag = MatchAll |  MatchOne

MatchState = [(MatchResult, [MatchAtom])]

MatchAtom = (Matcher, Pattern, Target)
